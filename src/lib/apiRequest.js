import axios from "axios";
import { Button } from "antd";
import { ENDPOINT } from "./endpoints";
import "../App.css";
const instance = axios.create({
  headers: {
    "Content-Type": "application/json",
  },
});

async function Request(props) {
  const request = {
    url: "",
    headers: {
      "Content-Type": "*/*",
    },
    data: null,
  };
  const controller = new AbortController();

  const handleCancel = () => {
    controller.abort();
  };
  const Cancel = () => {
    return (
      <>
        <p>Request in progress.....</p>
        <Button onClick={() => handleCancel()}>Cancel Request</Button>
      </>
    );
  };

  if (props?.dispatch) {
    props?.dispatch({ spin: true, tip: <Cancel /> });
  }

  request.method = props?.method ?? "get";
  request.url = props?.url;
  request.data = props?.data;
  request.headers = props?.headers;

  // console.log(request);
  const connect = async () => {
    try {
      if (request.method === "post") {
        const response = await instance.post(
          request.url,
          request.data,
          { headers: request.headers },
          {
            signal: controller.signal,
          },
          {
            onUploadProgress: function (progressEvent) {
              console.log(progressEvent);
            },
          },
          {
            onDownloadProgress: function (progressEvent) {
              console.log(progressEvent);
            },
          }
        );
        if (props?.dispatch) props?.dispatch({ spin: false });
        return response.data;
      } else if (request.method === "get") {
        const response = await instance.get(
          request.url,
          { headers: request.headers },
          {
            signal: controller.signal,
          },
          {
            onUploadProgress: function (progressEvent) {
              console.log(progressEvent);
            },
          },
          {
            onDownloadProgress: function (progressEvent) {
              console.log(progressEvent);
            },
          }
        );
        if (props?.dispatch) props?.dispatch({ spin: false });
        return response.data;
      }
    } catch (error) {
      if (props?.dispatch) props?.dispatch({ spin: false });
      return { type: "error", message: error.message };
    }
  };
  let data = await connect();
  // console.log(data);
  if (
    typeof data === "string" &&
    data.indexOf("<!-- Generated by Webspeed: http://www.webspeed.com/ -->") >
      -1
  )
    data = {
      type: "error",
      message: `Server error returned with: \n\n${data}`,
    };
  return data;
}

async function login(params) {
  if (!params) {
    throw Error(
      "login function required userid and password wrapped in an object {uid:<ID>,pass:<password>}"
    );
  }
  if (!params.uid || params.uid === null || params.uid === "") {
    return { type: "error", message: "Userid is missing" };
  }
  if (!params.pass || params.pass === null || params.pass === "") {
    return { type: "error", message: "Password is missing" };
  }

  const data = {
    credApp: "CONNECT",
    credId: params.uid,
    credPwd: params.pass,
    credType: params.type,
  };

  const base64Data = btoa(JSON.stringify(data));
  const result = await axios

    .post("http://tisdev/tiscode/cgi/tiscode.sh/onetis/auth/api/weblogin", {
      authToken: base64Data,
    })
    .then((response) => {
      // console.log(response.data);
      return response.data;
    })
    .catch((error) => {
      // console.log(error);
      return error;
    });

  return result;
}

export function download(props) {
  const { fileName, fileContent } = props;
  // const name = !fileName || fileName === "" ? "Untitled" : fileName;
  const name =
    !fileName || fileName === "" || fileName?.split("/")?.length === 0
      ? "Untitled"
      : fileName?.split("/")?.[fileName?.split("/")?.length - 1];
  const element = document.createElement("a");
  const tempFile = new Blob([fileContent], {
    type: "text/plain",
  });
  element.href = URL.createObjectURL(tempFile);
  element.download = name;
  document.body.appendChild(element); // Required for this to work in FireFox
  element.click();
}

export async function downloadAsync(fileName) {
  /***
   * @param {fileName: Full server path of the filename such as /path/to/file/filename}
   * @invoke Invoke it with await by declaring its outer function as async
   *         async function downloadFile(fileName) {
   *           await saveToComputerAsync(fileName);
   *         }
   * @returns null
   */
  if (!fileName || fileName === "" || fileName?.split("/")?.length <= 1) {
    console.error(
      "Invalid file. File provided must have a path associated with it such as /var/tmp/myfile.txt"
    );
    return null;
  }
  document.body.classList.add("waiting");
  // const { fileName, fileContent } = props;
  const response = await Request({
    url: ENDPOINT.getFileContentApi() + `?file=${fileName}`,
  });

  if (response?.type === "error") {
    console.error(`File retrieve error from server: ${response?.message}`);
    document.body.classList.remove("waiting");
    return;
  }
  const fileContent = response?.data;
  const name =
    !fileName || fileName === "" || fileName?.split("/")?.length === 0
      ? "Untitled"
      : fileName?.split("/")?.[fileName?.split("/")?.length - 1];
  const element = document.createElement("a");
  const tempFile = new Blob([fileContent], {
    type: "text/plain",
  });
  element.href = URL.createObjectURL(tempFile);
  element.download = name;
  document.body.appendChild(element); // Required for this to work in FireFox
  element.click();
  document.body.classList.remove("waiting");
}

export { Request, login };
